找出数量最大同时用量最小
分别对两个量排序 保存到2个表 对比2个表是否同时满足条件



不清标记bug
去掉回车 直接出结果(可能卡顿)

location.reload();


插入排序
function insertionSort(array) {
  var len = array.length;
  for (var i = 0; i < len; i++) {
    var current = array[i];
    var j = i - 1;
    while (j >= 0 && array[j] > current) {
      array[j + 1] = array[j];
      j--;
    }
    array[j + 1] = current;
  }
  return array;
}


程序运行时间
console.time('test');
for (var i = 0; i < 1000000; i++) {
  // 在这里运行需要测量时间的程序代码
}
console.timeEnd('test');










在JavaScript中，当需要操作大量元素时，可以采用以下几种方法来提高性能：

使用querySelectorAll()代替getElementsByTagName()
getElementsByTagName()会从整个文档树中查找节点元素，而且是动态实时求值的，每次检索都需要浪费性能，所以避免使用此方法。相反，可以使用querySelectorAll()选择匹配特定选择器的元素，以减少元素集合的大小。

使用虚拟滚动技术
当页面上需要展示大量元素时，如列表、表格等，使用虚拟滚动技术能够有效地提高性能。虚拟滚动技术只在视口内渲染必要的元素，当用户滚动视图时，再动态加载更多的元素。

避免在布局和绘制期间触发回流
回流是导致性能下降的主要原因之一，可以避免回流的方法包括：

避免多次读取DOM元素的布局信息，使用变量保存信息
缓存DOM元素的样式信息
使用requestAnimationFrame()等工具，在下一个重绘周期中完成DOM操作
使用事件委托
使用事件委托技术，将事件处理程序绑定到父元素上，以代替为每个子元素都绑定事件处理程序。

分批次加载数据
在实现列表、表格等组件时，可以使用分批次加载数据的方式，即在页面渲染完成后，每次只加载一部分数据，并通过事件等方式触发后续数据加载。这种方式可以减轻浏览器的负担，并提高用户体验。

总之，在处理大量元素时，需要避免浪费性能和资源。以上提到的方法都是有效的优化方案，但具体实现应因情况而异。
